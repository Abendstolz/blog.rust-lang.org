<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>

    
    <entry>
        <title>A call for Rust 2019 Roadmap blog posts</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html" type="text/html" title="A call for Rust 2019 Roadmap blog posts" />
        <published>2018-12-06</published>
        <id>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html">&lt;p&gt;It's almost 2019! As such, the Rust team needs to create a roadmap for Rust's
development next year. At the highest level, Rust's development process looks
like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Rust community blogs about what they'd like to see.&lt;/li&gt;
&lt;li&gt;The core team reads these posts, and produces a &amp;quot;roadmap RFC,&amp;quot; a proposal
for what next year's development looks like.&lt;/li&gt;
&lt;li&gt;The RFC is widely discussed, and modified in response to feedback, and
eventually accepted.&lt;/li&gt;
&lt;li&gt;This RFC becomes a guideline for accepting or postponing RFCs for the next
year.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We try to align this with the calendar year, but it doesn't 100% match up,
currently. Last year, &lt;a href=&quot;https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html&quot;&gt;we had a call for posts on January
3&lt;/a&gt;,
the roadmap RFC was opened &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314&quot;&gt;on Jan
29th&lt;/a&gt;, and was &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314#issuecomment-370576889&quot;&gt;accepted on
March
5th&lt;/a&gt;.
This year, we're starting a bit earlier, but it's still not going to be
accepted before January 1.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#we-need-you&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;we-need-you&quot;&gt;&lt;/a&gt;We need you&lt;/h2&gt;
&lt;p&gt;Starting today and running until of January 15, we’d like to ask the
community to write blogposts reflecting on Rust in 2018 and proposing goals
and directions for Rust in 2019. Like last year, these can take many forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A post on your personal or company blog&lt;/li&gt;
&lt;li&gt;A Medium post&lt;/li&gt;
&lt;li&gt;A GitHub gist&lt;/li&gt;
&lt;li&gt;Or any other online writing platform you prefer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We’re looking for posts on many topics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ideas for community programs&lt;/li&gt;
&lt;li&gt;Language features&lt;/li&gt;
&lt;li&gt;Documentation improvements&lt;/li&gt;
&lt;li&gt;Ecosystem needs&lt;/li&gt;
&lt;li&gt;Tooling enhancements&lt;/li&gt;
&lt;li&gt;Or anything else Rust related you hope for in 2019&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's one additional thing this year, however. With the shipping of Rust
2018 today, it's time to think about the next edition. In other words:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust 2015: Stability&lt;/li&gt;
&lt;li&gt;Rust 2018: Productivity&lt;/li&gt;
&lt;li&gt;Rust 2021: ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We aren't yet &lt;em&gt;committing&lt;/em&gt; to an edition in 2021, but that's the current
estimate. Each edition has had some sort of theme associated with it. As
such, we wouldn't just like to know what you're thinking for Rust in 2019,
but also, what you want the theme of Rust 2021 to be. Ideally, suggestions
for Rust in 2019 will fit into the overall goal of the next edition, though
of course, three years is a lot of time, and so not every single thing must.
As Rust matures, we need to start thinking of ever-longer horizons, and how
our current plans fit into those eventual plans.&lt;/p&gt;
&lt;p&gt;If you're not sure what to write, check out all of the blog posts from last
year &lt;a href=&quot;https://readrust.net/rust-2018/&quot;&gt;over at ReadRust&lt;/a&gt;. They may give you
some inspiration!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#please-share-these-posts-with-us&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;please-share-these-posts-with-us&quot;&gt;&lt;/a&gt;Please share these posts with us&lt;/h2&gt;
&lt;p&gt;You can write up these posts and email them to &lt;code&gt;community@rust-lang.org&lt;/code&gt; or
tweet them with the hashtag &lt;code&gt;#rust2019&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Core team will be reading all of the submitted posts and using them to
inform the initial roadmap RFC for 2019. Once the RFC is submitted, we’ll
open up the normal RFC process, though if you want, you are welcome to write
a post and link to it on the GitHub discussion.&lt;/p&gt;
&lt;p&gt;We look forward to working with the entire community to make Rust even more
wonderful in 2019. Thanks for an awesome 2018!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.31 and Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html" type="text/html" title="Announcing Rust 1.31 and Rust 2018" />
        <published>2018-12-06</published>
        <id>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.31.0, and &amp;quot;Rust
2018&amp;quot; as well. Rust is a programming language that empowers everyone to build
reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.31.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes for
1.31.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.31.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.31.0-stable&quot;&gt;&lt;/a&gt;What's in 1.31.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.31 may be the most exciting release since Rust 1.0! Included in this release is the
first iteration of &amp;quot;Rust 2018,&amp;quot; but there's more than just that! This is going to be a long
post, so here's a table of contents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rust-2018&quot;&gt;Rust 2018&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#non-lexical-lifetimes&quot;&gt;Non-lexical lifetimes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#module-system-changes&quot;&gt;Module system changes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#more-lifetime-elision-rules&quot;&gt;More lifetime elision rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#const-fn&quot;&gt;&lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#new-tools&quot;&gt;New tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tool-lints&quot;&gt;Tool Lints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#documentation&quot;&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#domain-working-groups&quot;&gt;Domain working groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#new-website&quot;&gt;New website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#library-stabilizations&quot;&gt;Library stabilizations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cargo-features&quot;&gt;Cargo features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#contributors-to-1310&quot;&gt;Contributors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#rust-2018&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-2018&quot;&gt;&lt;/a&gt;Rust 2018&lt;/h3&gt;
&lt;p&gt;We wrote about Rust 2018 &lt;a href=&quot;https://blog.rust-lang.org/2018/03/12/roadmap.html&quot;&gt;first in
March&lt;/a&gt;, &lt;a href=&quot;https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html&quot;&gt;and then in
July&lt;/a&gt;.
For some more background about the &lt;em&gt;why&lt;/em&gt; of Rust 2018, please go read those
posts; there's a lot to cover in the release announcement, and so we're going
to focus on the &lt;em&gt;what&lt;/em&gt; here. There's also a &lt;a href=&quot;https://hacks.mozilla.org/2018/12/rust-2018-is-here/&quot;&gt;post on Mozilla Hacks&lt;/a&gt; as
well!&lt;/p&gt;
&lt;p&gt;Briefly, Rust 2018 is an opportunity to bring
all of the work we've been doing over the past three years together, and create
a cohesive package. This is more than just language features, it also includes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tooling (IDE support, &lt;code&gt;rustfmt&lt;/code&gt;, Clippy)&lt;/li&gt;
&lt;li&gt;Documentation&lt;/li&gt;
&lt;li&gt;Domain working groups work&lt;/li&gt;
&lt;li&gt;A new web site&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll be covering all of this and more in this post.&lt;/p&gt;
&lt;p&gt;Let's create a new project with Cargo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ cargo new foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here's the contents of &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[package]
name = &amp;quot;foo&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Your Name &amp;lt;you@example.com&amp;gt;&amp;quot;]
edition = &amp;quot;2018&amp;quot;

[dependencies]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new key has been added under &lt;code&gt;[package]&lt;/code&gt;: &lt;code&gt;edition&lt;/code&gt;. Note that it has been
set to &lt;code&gt;2018&lt;/code&gt;. You can also set it to &lt;code&gt;2015&lt;/code&gt;, which is the default if the key
does not exist.&lt;/p&gt;
&lt;p&gt;By using Rust 2018, some new features are unlocked that are not allowed in
Rust 2015.&lt;/p&gt;
&lt;p&gt;It is important to note that each package can be in either 2015 or
2018 mode, and they work seamlessly together. Your 2018 project can use 2015
dependencies, and a 2015 project can use 2018 dependencies. This ensures that
we don't split the ecosystem, and all of these new things are opt-in,
preserving compatibility for existing code. Furthermore, when you do choose
to migrate Rust 2015 code to Rust 2018, the changes can be made
automatically, via &lt;code&gt;cargo fix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What kind of new features, you may ask? Well, first, features get added to
Rust 2015 unless they require some sort of incompatibility with 2015's
features. As such, most of the language is available everywhere. You can
check out &lt;a href=&quot;https://doc.rust-lang.org/edition-guide&quot;&gt;the edition
guide&lt;/a&gt; to check each
feature's minimum &lt;code&gt;rustc&lt;/code&gt; version as well as edition requirements. However,
there are a few big-ticket features we'd like to mention here: non-lexical
lifetimes, and some module system improvements.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#non-lexical-lifetimes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;non-lexical-lifetimes&quot;&gt;&lt;/a&gt;Non-lexical lifetimes&lt;/h4&gt;
&lt;p&gt;If you've been following Rust's development over the past few years, you may
have heard the term &amp;quot;NLL&amp;quot; or &amp;quot;non-lexical lifetimes&amp;quot; thrown around. This is
jargon, but it has a straightforward translation into simpler terms: the
borrow checker has gotten smarter, and now accepts some valid code that it
previously rejected. Consider this example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;

    let y = &amp;amp;x;

    let z = &amp;amp;mut x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In older Rust, this is a compile-time error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:18
  |
4 |     let y = &amp;amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |                  ^ mutable borrow occurs here
6 | }
  | - immutable borrow ends here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because lifetimes follow &amp;quot;lexical scope&amp;quot;; that is, the borrow from &lt;code&gt;y&lt;/code&gt;
is considered to be held until &lt;code&gt;y&lt;/code&gt; goes out of scope at the end of main, even
though we never use &lt;code&gt;y&lt;/code&gt; again. This code is fine, but the borrow checker could
not handle it.&lt;/p&gt;
&lt;p&gt;Today, this code will compile just fine.&lt;/p&gt;
&lt;p&gt;What if we did use &lt;code&gt;y&lt;/code&gt;, like this for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;
    let y = &amp;amp;x;
    let z = &amp;amp;mut x;
    
    println!(&amp;quot;y: {}&amp;quot;, y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Older Rust will give you this error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:18
  |
4 |     let y = &amp;amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |                  ^ mutable borrow occurs here
...
8 | }
  | - immutable borrow ends here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With Rust 2018, this error changes for the better:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:13
  |
4 |     let y = &amp;amp;x;
  |             -- immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |             ^^^^^^ mutable borrow occurs here
6 |     
7 |     println!(&amp;quot;y: {}&amp;quot;, y);
  |                       - borrow later used here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of pointing to where &lt;code&gt;y&lt;/code&gt; goes out of scope, it shows you where the
conflicting borrow occurs. This makes these sorts of errors far easier to
debug.&lt;/p&gt;
&lt;p&gt;In Rust 1.31, this feature is exclusive to Rust 2018. We plan to backport it
to Rust 2015 at a later date.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#module-system-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;module-system-changes&quot;&gt;&lt;/a&gt;Module system changes&lt;/h4&gt;
&lt;p&gt;The module system can be a struggle for people first learning Rust.
Everyone has their own things that take time to master, of course, but
there's a root cause for why it's so confusing to many: while there are
simple and consistent rules defining the module system, their consequences
can feel inconsistent, counterintuitive and mysterious.&lt;/p&gt;
&lt;p&gt;As such, the 2018 edition of Rust introduces a few changes to how paths work,
but they end up simplifying the module system, to make it more clear as to
what is going on.&lt;/p&gt;
&lt;p&gt;Here's a brief summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern crate&lt;/code&gt; is no longer needed in almost all circumstances.&lt;/li&gt;
&lt;li&gt;You can import macros with &lt;code&gt;use&lt;/code&gt;, rather than a &lt;code&gt;#[macro_use]&lt;/code&gt; attribute.&lt;/li&gt;
&lt;li&gt;Absolute paths begin with a crate name, where the keyword &lt;code&gt;crate&lt;/code&gt; refers to the current crate.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;foo.rs&lt;/code&gt; and &lt;code&gt;foo/&lt;/code&gt; subdirectory may coexist; &lt;code&gt;mod.rs&lt;/code&gt; is no longer needed when placing submodules in a subdirectory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall.&lt;/p&gt;
&lt;p&gt;There's a &lt;em&gt;lot&lt;/em&gt; of details here, so please read &lt;a href=&quot;https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html&quot;&gt;the edition
guide&lt;/a&gt;
for full details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#more-lifetime-elision-rules&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;more-lifetime-elision-rules&quot;&gt;&lt;/a&gt;More lifetime elision rules&lt;/h3&gt;
&lt;p&gt;Let's talk about a feature that's available in both editions: we've added
some additional elision rules for &lt;code&gt;impl&lt;/code&gt; blocks and function definitions.
Code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl&amp;lt;'a&amp;gt; Reader for BufReader&amp;lt;'a&amp;gt; {
    // methods go here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;can now be written like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl Reader for BufReader&amp;lt;'_&amp;gt; {
    // methods go here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;'_&lt;/code&gt; lifetime still shows that &lt;code&gt;BufReader&lt;/code&gt; takes a parameter, but we
don't need to create a name for it anymore.&lt;/p&gt;
&lt;p&gt;Lifetimes are still required to be defined in structs. However, we no longer
require as much boilerplate as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// Rust 2015
struct Ref&amp;lt;'a, T: 'a&amp;gt; {
    field: &amp;amp;'a T
}

// Rust 2018
struct Ref&amp;lt;'a, T&amp;gt; {
    field: &amp;amp;'a T
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;: 'a&lt;/code&gt; is inferred. You can still be explicit if you prefer. We're
considering some more options for elision here in the future, but have no
concrete plans yet.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;There's several ways to define a function in Rust: a regular function with
&lt;code&gt;fn&lt;/code&gt;, an unsafe function with &lt;code&gt;unsafe fn&lt;/code&gt;, an external function with &lt;code&gt;extern fn&lt;/code&gt;.
This release adds a new way to qualify a function: &lt;code&gt;const fn&lt;/code&gt;. It looks like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn foo(x: i32) -&amp;gt; i32 {
    x + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;const fn&lt;/code&gt; can be called like a regular function, but it can also be used
in any constant context. When it is, it is evaluated at compile time, rather
than at run time. As an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const SIX: i32 = foo(5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will execute &lt;code&gt;foo&lt;/code&gt; at compile time, and set &lt;code&gt;SIX&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const fn&lt;/code&gt;s cannot do everything that normal &lt;code&gt;fn&lt;/code&gt;s can do; they must
have deterministic output. This is important for soundness reasons.
Currently, &lt;code&gt;const fn&lt;/code&gt;s can do a minimal subset of operations. Here's
some examples of what you can do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arithmetic and comparison operators on integers&lt;/li&gt;
&lt;li&gt;All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Constructing arrays, structs, enums, and tuples&lt;/li&gt;
&lt;li&gt;Calls to other &lt;code&gt;const fn&lt;/code&gt;s&lt;/li&gt;
&lt;li&gt;Index expressions on arrays and slices&lt;/li&gt;
&lt;li&gt;Field accesses on structs and tuples&lt;/li&gt;
&lt;li&gt;Reading from constants (but not statics, not even taking a reference to a static)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; of references&lt;/li&gt;
&lt;li&gt;Casts, except for raw pointer to integer casts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll be growing the abilities of &lt;code&gt;const fn&lt;/code&gt;, but we've decided that
this is enough useful stuff to start shipping the feature itself.&lt;/p&gt;
&lt;p&gt;For full details, please see &lt;a href=&quot;https://doc.rust-lang.org/reference/items/functions.html#const-functions&quot;&gt;the
reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#new-tools&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-tools&quot;&gt;&lt;/a&gt;New tools&lt;/h3&gt;
&lt;p&gt;The 2018 edition signals a new level of maturity for Rust's tools ecosystem.
Cargo, Rustdoc, and Rustup have been crucial tools since 1.0; with the 2018
edition, there is a new generation of tools ready for all users: Clippy,
Rustfmt, and IDE support.&lt;/p&gt;
&lt;p&gt;Rust's linter, &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/&quot;&gt;&lt;code&gt;clippy&lt;/code&gt;&lt;/a&gt;, is
now available on stable Rust. You can install it via &lt;code&gt;rustup component add clippy&lt;/code&gt; and run it with &lt;code&gt;cargo clippy&lt;/code&gt;. Clippy is now considered 1.0, which
carries the same lint stability guarantees as rustc. New lints may be added,
and lints may be modified to add more functionality, however lints may never
be removed (only deprecated). This means that code that compiles under clippy
will continue to compile under clippy (provided there are no lints set to
error via &lt;code&gt;deny&lt;/code&gt;), but may throw new warnings.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rustfmt&quot;&gt;Rustfmt&lt;/a&gt; is a tool for formatting Rust
code. Automatically formatting your code lets you save time and arguments by
using the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md&quot;&gt;official Rust
style&lt;/a&gt;.
You can install with &lt;code&gt;rustup component add rustfmt&lt;/code&gt; and use it with &lt;code&gt;cargo fmt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This release includes Rustfmt 1.0. From now on we guarantee backwards
compatibility for Rustfmt: if you can format your code today, then the
formatting will not change in the future (only with the default options).
Backwards compatibility means that running Rustfmt on your CI is practical
(use &lt;code&gt;cargo fmt -- --check&lt;/code&gt;). Try that and 'format on save' in your editor to
revolutionize your workflow.&lt;/p&gt;
&lt;p&gt;IDE support is one of the most requested tooling features for Rust. There are
now multiple, high quality options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/8182-rust&quot;&gt;IntelliJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang-nursery/atom-ide-rust&quot;&gt;Atom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust-enhanced&quot;&gt;Sublime Text 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components&quot;&gt;Eclipse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Work on IDE support is not finished, in particular code completion is not up
to scratch in the RLS-based editors. However, if you mainly want support for
types, documentation, and 'go to def', etc. then you should be happy.&lt;/p&gt;
&lt;p&gt;If you have problems installing any of the tools with Rustup, try running
&lt;code&gt;rustup self update&lt;/code&gt;, and then try again.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tool-lints&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tool-lints&quot;&gt;&lt;/a&gt;Tool lints&lt;/h3&gt;
&lt;p&gt;In &lt;a href=&quot;https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html&quot;&gt;Rust 1.30&lt;/a&gt;, we
stabilized &amp;quot;tool attributes&amp;quot;, like &lt;code&gt;#[rustfmt::skip]&lt;/code&gt;. In Rust 1.31, we're
stabilizing something similar: &amp;quot;tool lints,&amp;quot; like
&lt;code&gt;#[allow(clippy::bool_comparison)]&lt;/code&gt; These give a namespace to lints, so that it's
more clear which tool they're coming from.&lt;/p&gt;
&lt;p&gt;If you previously used Clippy's lints, you can migrate like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// old
#![cfg_attr(feature = &amp;quot;cargo-clippy&amp;quot;, allow(bool_comparison))]

// new
#![allow(clippy::bool_comparison)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don't need &lt;code&gt;cfg_attr&lt;/code&gt; anymore! You'll also get warnings that can help you
update to the new style.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#documentation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;documentation&quot;&gt;&lt;/a&gt;Documentation&lt;/h3&gt;
&lt;p&gt;Rustdoc has seen a number of improvements this year, and we also shipped a
complete re-write of the &amp;quot;The Rust Programming Language.&amp;quot; Additionally, you
can &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;buy a dead-tree copy from No Starch Press&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We had previously called this the &amp;quot;second edition&amp;quot; of the book, but since
it's the first edition in print, that was confusing. We also want to
periodically update the print edition as well. In the end, after many
discussions with No Starch, we're going to be updating the book on the
website with each release, and No Starch will periodically pull in our
changes and print them. The book has been selling quite well so far, raising
money for &lt;a href=&quot;http://www.blackgirlscode.com/&quot;&gt;Black Girls Code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can find the new TRPL &lt;a href=&quot;https://doc.rust-lang.org/beta/book/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#domain-working-groups&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;domain-working-groups&quot;&gt;&lt;/a&gt;Domain working groups&lt;/h3&gt;
&lt;p&gt;We announced the formation of four working groups this year:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network services&lt;/li&gt;
&lt;li&gt;Command-line applications&lt;/li&gt;
&lt;li&gt;WebAssembly&lt;/li&gt;
&lt;li&gt;Embedded devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these groups has been working very hard on a number of things to
make Rust awesome in each of these domains. Some highlights:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network services has been shaking out the Futures interface, and async/await
on top of it. This hasn't shipped yet, but we're close!&lt;/li&gt;
&lt;li&gt;The CLI working group has been working on libraries and documentation for making awesome
command-line applications&lt;/li&gt;
&lt;li&gt;The WebAssembly group has been shipping a ton of world-class tooling for using Rust with wasm.&lt;/li&gt;
&lt;li&gt;Embedded devices has gotten ARM development working on stable Rust!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find out more about this work on the new website!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#new-website&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-website&quot;&gt;&lt;/a&gt;New Website&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html&quot;&gt;Last
week&lt;/a&gt;
we announced a new iteration of the web site. It's now been promoted to
rust-lang.org itself!&lt;/p&gt;
&lt;p&gt;There's still a ton of work to do, but we're proud of the year of work that it
took by many people to get it shipped.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;A bunch of &lt;code&gt;From&lt;/code&gt; implementations have been added:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u8&lt;/code&gt; now implements &lt;code&gt;From&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt;, and likewise for the other numeric types and their &lt;code&gt;NonZero&lt;/code&gt; equivalents&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;From&amp;lt;&amp;amp;Option&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, and likewise for &lt;code&gt;&amp;amp;mut&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these functions have been stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.align_to&quot;&gt;&lt;code&gt;slice::align_to&lt;/code&gt;&lt;/a&gt; and its mutable counterpart&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact&quot;&gt;&lt;code&gt;slice::chunks_exact&lt;/code&gt;&lt;/a&gt;,
as well as its mutable and &lt;code&gt;r&lt;/code&gt; counterparts (like
&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut&quot;&gt;&lt;code&gt;slice::rchunks_exact_mut&lt;/code&gt;&lt;/a&gt;) in all combinations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;Cargo will now download packages in parallel using HTTP/2.&lt;/p&gt;
&lt;p&gt;Additionally, now that &lt;code&gt;extern crate&lt;/code&gt; is not usually required, it would be
jarring to do &lt;code&gt;extern crate foo as bar;&lt;/code&gt; to rename a crate. As such, you can
do so in your &lt;code&gt;Cargo.toml&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
baz = { version = &amp;quot;0.1&amp;quot;, package = &amp;quot;foo&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, the equivalent&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies.baz]
version = &amp;quot;0.1&amp;quot;
package = &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, the &lt;code&gt;foo&lt;/code&gt; package will be able to be used via &lt;code&gt;baz&lt;/code&gt; in your code.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-131.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-131.0&quot;&gt;&lt;/a&gt;Contributors to 1.31.0&lt;/h2&gt;
&lt;p&gt;At the end of release posts, we normally thank &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.31.0&quot;&gt;the people who contributed to
this release&lt;/a&gt;. But for this
release, more so than others, this list does not truly capture the amount of
work and the number of people who have contributed. Each release is only six
weeks, but this release is the culmination of three years of effort, in
countless repositories, by numerous people. It's been a pleasure to work with
you all, and we look forward to continuing to grow in the next three years.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>A new look for rust-lang.org</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html" type="text/html" title="A new look for rust-lang.org" />
        <published>2018-11-29</published>
        <id>https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html">&lt;p&gt;Before 1.0, Rust had a reputation for changing the language on a near-daily
basis. By contrast, the website has looked pretty much the same. Here’s the
first version of rust-lang.org, seven years ago (courtesy of &lt;a href=&quot;https://web.archive.org/&quot;&gt;the WayBack
Machine&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www1.png&quot; alt=&quot;rust website in 2011&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In 2014, three years later:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www2.png&quot; alt=&quot;rust website in 2014&quot; /&gt;&lt;/p&gt;
&lt;p&gt;If you visit &lt;a href=&quot;https://rust-lang.org&quot;&gt;https://rust-lang.org&lt;/a&gt; today, you'll see this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www3.png&quot; alt=&quot;rust website in 2018&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Over time, we’ve grown to love it. It’s simple. Minimal. Familiar.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#improving-the-content&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improving-the-content&quot;&gt;&lt;/a&gt;Improving the content&lt;/h2&gt;
&lt;p&gt;But we can always do better. For example, the website suffers from what we
call “the fireflower problem.” First formulated by &lt;a href=&quot;http://seriouspony.com/&quot;&gt;Kathy
Sierra&lt;/a&gt;, and made into an image by Samuel Hulick:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fireflower.png&quot; alt=&quot;the fireflower&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We want Mario to use Rust, the fireflower, and turn into the ever-awesome
Fire Mario. But there’s a corollary here: it’s better to say “we will make
you into Fire Mario” than it is “we sell fire flowers.”&lt;/p&gt;
&lt;p&gt;(As an aside, we had a &lt;a href=&quot;https://brson.github.io/fireflowers/&quot;&gt;community discussion on this
topic&lt;/a&gt; back in 2016.)&lt;/p&gt;
&lt;p&gt;In other words, this list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zero-cost abstractions&lt;/li&gt;
&lt;li&gt;move semantics&lt;/li&gt;
&lt;li&gt;guaranteed memory safety&lt;/li&gt;
&lt;li&gt;threads without data races&lt;/li&gt;
&lt;li&gt;trait-based generics&lt;/li&gt;
&lt;li&gt;pattern matching&lt;/li&gt;
&lt;li&gt;type inference&lt;/li&gt;
&lt;li&gt;minimal runtime&lt;/li&gt;
&lt;li&gt;efficient C bindings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;doesn’t explain what you can &lt;em&gt;do&lt;/em&gt; with Rust, which leads people to say “Rust
seems neat, but I don’t know what I would actually use it for.”&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#improving-the-style&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improving-the-style&quot;&gt;&lt;/a&gt;Improving the style&lt;/h2&gt;
&lt;p&gt;We also like the minimalist style of the current site, but it also may be
&lt;em&gt;too&lt;/em&gt; minimal. Furthermore, it has no room to grow; we have more than just
rust-lang.org these days. We wanted a style that we could use to unify all of
the websites that we maintain in the Rust project; crates.io being a big one.
Its “pool table” design feels extremely different than rust-lang.org, which
is confusing.&lt;/p&gt;
&lt;p&gt;Doing this requires care, as we don’t want to make the website huge and
complicated, but at the same time, using more than black and blue might be
nice.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#the-beta&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-beta&quot;&gt;&lt;/a&gt;The beta&lt;/h2&gt;
&lt;p&gt;Today, we’d like to announce a beta of the new rust-lang.org. If you go to
&lt;a href=&quot;https://beta.rust-lang.org&quot;&gt;https://beta.rust-lang.org&lt;/a&gt;, you’ll see this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www4.png&quot; alt=&quot;beta rust website&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Its fresh visual design gives us a lot more flexibility in how we get
information across. It retains the minimalist spirit of the old site, while
adding some bold color and visual variety.&lt;/p&gt;
&lt;p&gt;We hope you like it as much as we do!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#some-highlights&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;some-highlights&quot;&gt;&lt;/a&gt;Some highlights&lt;/h3&gt;
&lt;p&gt;The new site puts the “why Rust?” question front-and-center, and includes
dedicated pages for the four application domains we targeted in 2018:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Embedded devices&lt;/li&gt;
&lt;li&gt;WebAssembly&lt;/li&gt;
&lt;li&gt;CLI apps&lt;/li&gt;
&lt;li&gt;Network services&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We have also revised the slogan. Historically, it has been:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rust is a systems programming language that runs blazingly fast, prevents
segfaults, and guarantees thread safety.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Like the bullet list of features, this doesn't convey what you can &lt;em&gt;do&lt;/em&gt; with
Rust. So we've updated the slogan:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rust: The programming language that empowers everyone to become a systems
programmer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We're still not sure we love the term &amp;quot;systems programming,&amp;quot; as it seems like
it means something different to everyone, but this iteration is significantly
better than the old one. Even if people have different ideas about what
&amp;quot;systems programming&amp;quot; means, they at least have some idea. &amp;quot;guarantees thread
safety,&amp;quot; not so much.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#future-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;future-work&quot;&gt;&lt;/a&gt;Future work&lt;/h2&gt;
&lt;p&gt;There’s still more work to do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some information on the old site, has not yet been ported over.&lt;/li&gt;
&lt;li&gt;Translations have regressed. We’re working on adding the proper
infrastructure here, and hope to be able to start accepting translations by
the end of the year.&lt;/li&gt;
&lt;li&gt;We need more polish and testing in a general sense.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please &lt;a href=&quot;https://github.com/rust-lang/beta.rust-lang.org/issues/new/choose&quot;&gt;file an
issue&lt;/a&gt; with any
feedback you have! We’re also looking for people with abilities of all kinds
to help maintain the site, and especially people with design, CSS, and
marketing skills. If you’d like to get involved, please &lt;a href=&quot;mailto:www@rust-lang.org&quot;&gt;email
us&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We’d like to ship this new site on December 6, with the release of Rust 2018.
Thank you for giving it a try before then, so we can work out any bugs we
find!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Survey 2018 Results</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html" type="text/html" title="Rust Survey 2018 Results" />
        <published>2018-11-27</published>
        <id>https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html">&lt;p&gt;Another year means another Rust survey, and this year marks Rust's third annual survey. This year, the survey launched for the first time in multiple languages. In total &lt;strong&gt;14&lt;/strong&gt; languages, in addition to English, were covered.  The results from non-English languages totalled &lt;em&gt;25% of all responses&lt;/em&gt; and helped pushed the number of responses to a new record of &lt;strong&gt;5991 responses&lt;/strong&gt;. Before we begin the analysis, we just want to give a big &amp;quot;thank you!&amp;quot; to all the people who took the time to respond and give us your thoughts. It’s because of your help that Rust will continue to improve year after year.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/1-Do_you_use_Rust.png&quot; alt=&quot;Do you use Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Despite having an increase in the number of responses, this year also saw an increase in the percentage of Rust users. Up from last year’s 66.9% Rust users, this year nearly three-quarters of responses were from Rust users.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#rust-users&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-users&quot;&gt;&lt;/a&gt;Rust Users&lt;/h1&gt;
&lt;h2&gt;&lt;a href=&quot;#time-with-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;time-with-rust&quot;&gt;&lt;/a&gt;&lt;strong&gt;Time with Rust&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/4-How_long_have_you_worked_in_Rust.png&quot; alt=&quot;How long have you worked in Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We’re seeing a steady stream of new users into Rust. At the time of the survey, ~23% of Rust users had been using it for 3 months or less.  Likewise, nearly a quarter of the users have used Rust for at least 2 years.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/5-How_long_did_it_take_to_be_productive.png&quot; alt=&quot;How long did it take to be productive&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Over 40% of Rust users felt productive in Rust in less than a month of use, and over 70% felt productive in their first year. Unfortunately, there is a noticeable struggle among users, as over 22% do not yet feel productive.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/5a-How_long_have_you_been_unproductive.png&quot; alt=&quot;How long have you been unproductive&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Looking closer at these users who feel unproductive in Rust, only about 25% are in their first month of use. The challenge here is to find ways to help bridge users to productivity so they don't get stuck.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#how-much-do-you-use-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-much-do-you-use-rust&quot;&gt;&lt;/a&gt;&lt;strong&gt;How much do you use Rust?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/6-Size_of_summed_Rust_projects.png&quot; alt=&quot;Size of summed Rust projects&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rust projects are continuing to trend to larger sizes, with larger overall investments. Medium to large investments in Rust (those totally over 10k and 100k lines of code respectively) have grown from 8.9% in 2016, to 16% in 2017, to &lt;strong&gt;23%&lt;/strong&gt; this year.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/7-How_often_use_Rust.png&quot; alt=&quot;How often do you use Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We’ve also seen a growth in Rust regular usage. Up from 17.5% last year, Rust daily usage is now nearly a quarter of users. In total, Rust weekly total usage has risen from 60.8% to 66.4%.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-expertise&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-expertise&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust expertise&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/8-How_you_rate_your_Rust_expertise.png&quot; alt=&quot;How would you rate your Rust expertise&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rather than being a simple curve, Rust expertise has two peaks: one around a &amp;quot;3&amp;quot;, and another at &amp;quot;7&amp;quot;, showing that users tend to see themselves as just above beginner or experienced without necessarily being expert.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/9-How_difficult_are_Rust_concepts.png&quot; alt=&quot;How difficult are Rust concepts&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rust users generally felt that Enums and Cargo were largely easy concepts; followed by Iterators, Modules, and Traits. More challenging concepts of Trait Bounds and Unsafe came next. Lastly, the most challenging concepts were Macros, Ownership &amp;amp; Borrowing, and Lifetimes. These challenges match closely to feedback we’ve heard in years past and continue to be a focus of continued productivity improvements like NLL and the continued macro system improvements.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/22-Programming_language_familiarity.png&quot; alt=&quot;What programming languages are you familiar with&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Humorously, we see that Rust isn't actually the top programming language that users were familiar with. Instead, it pulled in a 2nd place behind Python.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-toolchain&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-toolchain&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust toolchain&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/10-Which_Rust_version.png&quot; alt=&quot;Which Rust version do you use&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We’re seeing similar numbers in users of the current stable release since last year. Perhaps surprisingly, we’re continuing to see a rise in the number of users who use the Nightly compiler in their workflow. For the second year in a row, Nightly usage has continued to rise, and is now over 56% (up from 51.6% of last year).&lt;/p&gt;
&lt;p&gt;When asked why they used nightly, people responded with a broad range of reasons including: access to 2018 edition, asm, async/await, clippy, embedded development, rocket, NLL, proc macros, and wasm.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/11-Has_upgrading_compiler_broken_you.png&quot; alt=&quot;Has upgrading the compiler broken your code&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The percentage of people who see a breakage during a routine compiler update has stayed the same since last year, with 7.4% saying they’ve experienced breakage.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/12-If_so_how_much_work_to_fix.png&quot; alt=&quot;If so how much work to fix it&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Breakages generally leaned to requiring minor fixes, though some reported having moderate or major fixes to upgrade to the next stable compiler.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/13-Preferred_install_method.png&quot; alt=&quot;Preferred install method&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We again see a strong showing for &lt;code&gt;rustup&lt;/code&gt;, which continues to hold at 90% of Rust installs. Linux distros follow as a distant second at 17%.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/14-Tool-experience.png&quot; alt=&quot;Experience with Rust tools&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Tools like &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;rustdoc&lt;/code&gt; had a strong show, with lots of positive support.  Following these is the &lt;code&gt;clippy&lt;/code&gt; tool -- despite having fewer users, its users enjoy the tool.  The IDE support tools &lt;code&gt;Rust Language Server&lt;/code&gt; and &lt;code&gt;racer&lt;/code&gt; had positive support but unfortunately, of the tools surveyed, generated a few more dislike votes and comments. The &lt;code&gt;bindgen&lt;/code&gt; tool has relatively small userbase.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-workflow&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-workflow&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust workflow&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/15-Platform_developing_on.png&quot; alt=&quot;Which platform are you developing on&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Linux continues to be a powerhouse among Rust developers, holding on to roughly 80% of Rust developers.  Windows usage has grown slightly from 31% last year to 34% this year, its second year in a row of growth.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/16-Platforms_targeting.png&quot; alt=&quot;Which platforms are you developing for&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Linux and Windows continued to show strongly as targets for Rust applications. Other platforms held largely the same as last year, with one exception: WebAssembly. The new technology has showed impressive growth, nearly doubling from last year's 13% to this year's 24%.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/17-Editors.png&quot; alt=&quot;What editors do you use&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Vim, the front-runner in editors for two years has now finally been bested by VSCode, which grew from 33.8% of Rust developers to 44.4% this year.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-at-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-at-work&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust at work&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/18-Rust_at_work.png&quot; alt=&quot;Do you use Rust at work&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rust continues is slow-and-steady growth in the workplace. We're now seeing year-over-year growth of full-time and part-time Rust, growing from last year's 4.4% full-time and 16.6% part-time to this year's &lt;strong&gt;8.9% full-time&lt;/strong&gt; and &lt;strong&gt;21.2% part-time&lt;/strong&gt;, a doubling of full-time Rust commercial use.  In total, Rust commercial use grew from 21% to just over 30% of Rust users.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/19-Company_evaluate_Rust.png&quot; alt=&quot;Is your company evaluating Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;There is more room for Rust to grow into more companies, over a third of which users report aren't currently looking into evaluating Rust in the coming year.  When paired with the survey data that said that nearly half of non-users needed the company support, this shows the need for further company outreach or more company-focused information about Rust.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#feeling-welcome&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;feeling-welcome&quot;&gt;&lt;/a&gt;&lt;strong&gt;Feeling welcome&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/23-Do_you_feel_welcome.png&quot; alt=&quot;Do you feel welcome in the Rust community&quot; /&gt;&lt;/p&gt;
&lt;p&gt;An important part of the Rust community efforts are ensuring that the Rust project is a welcoming place for its users. New users should feel encouraged to explore, share ideas, and generally be themselves.&lt;/p&gt;
&lt;p&gt;When asked, both current Rust users and non-users largely felt welcome, though over a quarter of responses weren't sure.  There was also some regional variation in these responses.  For example, responses on the Russian version of the survey showed double the percent of unwelcome feelings at 4%. Mainland China showed even more at 8%.&lt;/p&gt;
&lt;p&gt;There's a challenge here to help Rust communities worldwide feel like they are part of what makes Rust unique, as Rust continues to grow a strong presence in more areas of the world.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/24-Underrepresented.png&quot; alt=&quot;Are you underrepresented in tech&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The number of people in Rust who self-identify as being part of a group underrepresented in technology is growing slowly year-over-year. The survey also highlights some challenges, as the number of women is still lower than the industry average of women in programming fields.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#rust-non-users&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-non-users&quot;&gt;&lt;/a&gt;Rust Non-Users&lt;/h1&gt;
&lt;p&gt;A big part of a welcoming Rust community is reaching out to non-users as well. As we have in years past, we again asked the reasons why people weren't using Rust.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/2-How_long_before_you_stopped.png&quot; alt=&quot;How long before you stopped&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For those who stopped using Rust, just over 50% stopped using Rust in less than a month. Likewise, roughly 50% of people who left Rust managed to use it for more than a month before stopping.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/3-Why_not_using_Rust.png&quot; alt=&quot;Why are you not using Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Many non-users responded that they did want to learn Rust, but there were factors that slowed them down. First among these is that the companies the responders work for do not themselves use Rust. Nearly one half of the non-users were blocked by the lack of company support.&lt;/p&gt;
&lt;p&gt;Additionally, 1 in 4 non-users were slowed by the feeling of Rust being too intimidating or complicated. The work towards improving Rust IDE support has helped (down from 25% to 16%), though we still see a strong push towards even better IDE support among non-users.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#challenges&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;challenges&quot;&gt;&lt;/a&gt;Challenges&lt;/h1&gt;
&lt;p&gt;As we've done in past years, we asked for your comments in where Rust can improve. This year, we see some familiar themes as well as some new ones in this feedback. The top ten themes this year are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the need for better library support&lt;/li&gt;
&lt;li&gt;a more improved IDE experience&lt;/li&gt;
&lt;li&gt;the need for broader adoption of Rust generally&lt;/li&gt;
&lt;li&gt;a richer ecosystem of tools and support&lt;/li&gt;
&lt;li&gt;an improved learning curve&lt;/li&gt;
&lt;li&gt;the need for important language features and crates to be stable and supported&lt;/li&gt;
&lt;li&gt;support for async programming&lt;/li&gt;
&lt;li&gt;support for GUI development&lt;/li&gt;
&lt;li&gt;better documentation&lt;/li&gt;
&lt;li&gt;improved compile times&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;New this year is the rising need to &lt;strong&gt;support GUI development&lt;/strong&gt;, showing that Rust continues to grow not only on the server, but that people are feeling the need to stretch into application development.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Improve Rust marketing. Many people don't know about it&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Comments remind us that while Rust may be well-known in some circles, it still has room to grow and in many tech circles Rust may not yet be well-known.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Keeping a focus on adoption/tutorials/books/novice experience will pay dividends in the years to come.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In addition to outreach, a broader set of documentation would in turn help reach a broader audience.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Stability and maturity of developer tools, make it easier to get a working setup and to debug applications&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many people commented on the IDE support, pointing out not only instability or inaccuracy in the RLS, but also the need for a much stronger IDE story that covered more areas, like easier debugging.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;The maturity of the ecosystem and libraries. Have a good ecosystem of &amp;quot;standard&amp;quot; libraries is key for the future of the language&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A common theme continues to be the need to push libraries to completion and grow the set of &amp;quot;standard&amp;quot; libraries that users can use. Some comments point out this isn't the fault of maintainers, who are already working hard to write and publish the crates, but that generally more companies need to get involved and offer commercial support.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Ergonomics and discoverability of &amp;quot;putting it together&amp;quot; documentation&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some people pointed out that ergonomics goes hand in hand with richer documentation, seeing that these aren't separate concepts but rather challenges that should be tackled together in a unified approach.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#looking-forward&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;looking-forward&quot;&gt;&lt;/a&gt;Looking forward&lt;/h2&gt;
&lt;p&gt;This year saw the strongest survey yet. Not only was it the largest community survey, it was the first to cover languages outside of English. Rust continues to grow steadily, and with it, both its strengths and challenges are introduced to a broader audience.&lt;/p&gt;
&lt;p&gt;We look forward to using your feedback in planning for 2019, and we're excited to see where we can take Rust next.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.30.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/11/08/Rust-1.30.1.html" type="text/html" title="Announcing Rust 1.30.1" />
        <published>2018-11-08</published>
        <id>https://blog.rust-lang.org/2018/11/08/Rust-1.30.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/11/08/Rust-1.30.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.30.1. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.30.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1301-2018-11-08&quot;&gt;detailed release notes for
1.30.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.30.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.30.1-stable&quot;&gt;&lt;/a&gt;What's in 1.30.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes broken Cargo progress bars in MSYS terminals on
Windows by &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6122&quot;&gt;capping the progress bar width to 60 columns&lt;/a&gt;. This doesn't affect
other terminal emulators (like &lt;code&gt;cmd.exe&lt;/code&gt; or PowerShell).&lt;/p&gt;
&lt;p&gt;This patch release also &lt;a href=&quot;https://github.com/rust-lang/rust/pull/54199&quot;&gt;fixes a compiler panic&lt;/a&gt; that happened while building the
docs of some crates in Rust 1.30.0. The crates impacted were widely used, so
this change impacted a considerable amount of users, which made it sufficiently
prominent for us to issue a point release.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Help test Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/10/30/help-test-rust-2018.html" type="text/html" title="Help test Rust 2018" />
        <published>2018-10-30</published>
        <id>https://blog.rust-lang.org/2018/10/30/help-test-rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/10/30/help-test-rust-2018.html">&lt;p&gt;Back in July, we talked about &lt;a href=&quot;https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html&quot;&gt;&amp;quot;Rust 2018&amp;quot;&lt;/a&gt;. In short, we are launching a
cycle of long-term milestones called &amp;quot;Editions&amp;quot;. Editions are a way to
capture the progress delivered incrementally by our ordinary six-week release
cycle -- and focus Rust libraries, tooling, and documentation cohesively
around it. Editions will be selected roughly every three years: Rust 1.0 was
&amp;quot;Rust 2015&amp;quot; and Rust 1.31 will be &amp;quot;Rust 2018&amp;quot;. Each edition has a theme;
Rust 2015's was &amp;quot;stability&amp;quot;, and Rust 2018's is &amp;quot;productivity.&amp;quot;&lt;/p&gt;
&lt;p&gt;We've been &lt;a href=&quot;https://internals.rust-lang.org/t/rust-2018-release-schedule-and-extended-beta/8076&quot;&gt;testing Rust 2018 for a while already&lt;/a&gt;, and things are looking
pretty good! We have just under six weeks until Rust 1.31 ships, and so
we'd appreciate it if you could give the beta a try.&lt;/p&gt;
&lt;p&gt;There's two ways to try out Rust 2018: updating an existing project, and
starting a new one. For full details, please check out the &lt;a href=&quot;https://rust-lang-nursery.github.io/edition-guide/&quot;&gt;Edition Guide&lt;/a&gt;,
but the rest of this post is a quickstart to make it even easier.&lt;/p&gt;
&lt;p&gt;If anything goes wrong, or is confusing, please &lt;a href=&quot;https://github.com/rust-lang/rust/issues/new&quot;&gt;file an issue&lt;/a&gt; and let us
know. We want to make sure this is an extra-awesome release! Thank you for
helping us make Rust even better. &amp;lt;3&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#setup-install-rust-beta&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;setup-install-rust-beta&quot;&gt;&lt;/a&gt;Setup: install Rust beta&lt;/h2&gt;
&lt;p&gt;First things first, you'll need to install the beta release channel of Rust.
With &lt;a href=&quot;https://www.rust-lang.org/en-US/install.html&quot;&gt;Rustup&lt;/a&gt;, it's as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup install beta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use this channel of Rust instead of your default, you can append a &lt;code&gt;+beta&lt;/code&gt;
to any &lt;code&gt;rustc&lt;/code&gt; or cargo commands:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustc +beta --version
$ cargo +beta build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This lets you stick to stable as the default, while using beta for your
experiments.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#start-a-new-project&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;start-a-new-project&quot;&gt;&lt;/a&gt;Start a new project&lt;/h2&gt;
&lt;p&gt;To start a new project with Rust 2018:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ cargo +beta new my-sample-project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing changes! Well, something changed. Check out &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[package]
name = &amp;quot;my-sample-project&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Your Name &amp;lt;you@example.com&amp;gt;&amp;quot;]
edition = &amp;quot;2018&amp;quot;

[dependencies]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That new &lt;code&gt;edition = &amp;quot;2018&amp;quot;&lt;/code&gt; key/value pair means you're working with Rust 2018.
If it doesn't exist, it's the same as &lt;code&gt;edition = &amp;quot;2015&amp;quot;&lt;/code&gt;, so all
existing projects keep working.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#convert-an-existing-project&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;convert-an-existing-project&quot;&gt;&lt;/a&gt;Convert an existing project&lt;/h2&gt;
&lt;p&gt;You can also convert an existing project to Rust 2018. Remember, none of your
dependencies need to be updated for this to work; Rust 2018 and 2015
interoperate seamlessly!&lt;/p&gt;
&lt;p&gt;The first step is to run &lt;code&gt;cargo fix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ cargo fix --edition
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will check your code, and automatically fix any issues that it can.
&lt;code&gt;cargo fix&lt;/code&gt; is still pretty new, and so it can't always fix your code
automatically. If &lt;code&gt;cargo fix&lt;/code&gt; can't fix something, it will print the warning
that it cannot fix to the console. If you see one of these warnings, you'll
have to update your code manually. See the corresponding section of the
edition guide for help, and if you have problems, please seek help at the
user's forums.&lt;/p&gt;
&lt;p&gt;Keep running &lt;code&gt;cargo fix --edition&lt;/code&gt; until you have no more warnings.&lt;/p&gt;
&lt;p&gt;Congrats! Your code is now valid in both Rust 2015 and Rust 2018!&lt;/p&gt;
&lt;p&gt;Once this is done, you can commit to Rust 2018 by updating
your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[package]
name = &amp;quot;my-sample-project&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Your Name &amp;lt;you@example.com&amp;gt;&amp;quot;]
edition = &amp;quot;2018&amp;quot;

[dependencies]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See that &lt;code&gt;edition = &amp;quot;2018&amp;quot;&lt;/code&gt;? That's what opts you in to the new features.
Set it, &lt;code&gt;cargo +beta build&lt;/code&gt;, and you should be good to go!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.30</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html" type="text/html" title="Announcing Rust 1.30" />
        <published>2018-10-25</published>
        <id>https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.30.0. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.30.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1300-2018-10-25&quot;&gt;detailed release notes for
1.30.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.30.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.30.0-stable&quot;&gt;&lt;/a&gt;What's in 1.30.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.30 is an exciting release with a number of features. On Monday, expect another
blog post asking you to check out Rust 1.31's beta; Rust 1.31 will be the first release
of &amp;quot;Rust 2018.&amp;quot; For more on that concept, please see our previous post
&lt;a href=&quot;https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html&quot;&gt;&amp;quot;What is Rust 2018&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#procedural-macros&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;procedural-macros&quot;&gt;&lt;/a&gt;Procedural Macros&lt;/h2&gt;
&lt;p&gt;Way back in &lt;a href=&quot;https://blog.rust-lang.org/2017/02/02/Rust-1.15.html&quot;&gt;Rust 1.15&lt;/a&gt;, we announced the ability to define &amp;quot;custom derives.&amp;quot; For example,
with &lt;code&gt;serde_derive&lt;/code&gt;, you could&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[derive(Serialize, Deserialize, Debug)]
struct Pet {
    name: String,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And convert a &lt;code&gt;Pet&lt;/code&gt; to and from JSON using &lt;code&gt;serde_json&lt;/code&gt; because &lt;code&gt;serde_derive&lt;/code&gt;
defined &lt;code&gt;Serialize&lt;/code&gt; and &lt;code&gt;Deserialize&lt;/code&gt; in a procedural macro.&lt;/p&gt;
&lt;p&gt;Rust 1.30 expands on this by adding the ability to define two other kinds of
advanced macros, &amp;quot;attribute-like procedural macros&amp;quot; and &amp;quot;function-like
procedural macros.&amp;quot;&lt;/p&gt;
&lt;p&gt;Attribute-like macros are similar to custom derive macros, but instead of generating code
for only the &lt;code&gt;#[derive]&lt;/code&gt; attribute, they allow you to create new, custom attributes of
your own. They're also more flexible: derive only works for structs and enums, but
attributes can go on other places, like functions. As an example of using an
attribute-like macro, you might have something like this when using a web application
framework:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#[route(GET, &amp;quot;/&amp;quot;)]
fn index() {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;#[route]&lt;/code&gt; attribute would be defined by the framework itself, as a
procedural macro. Its signature would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we have two input &lt;code&gt;TokenStreams&lt;/code&gt;: the first is for the contents of the
attribute itself, that is, the &lt;code&gt;GET, &amp;quot;/&amp;quot;&lt;/code&gt; stuff. The second is the body of the
thing the attribute is attached to, in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest
of the function's body.&lt;/p&gt;
&lt;p&gt;Function-like macros define macros that look like function calls. For
example, the &lt;a href=&quot;https://gitlab.gnome.org/federico/gnome-class&quot;&gt;&lt;code&gt;gnome-class&lt;/code&gt; crate&lt;/a&gt;
has a procedural macro that defines &lt;code&gt;GObject&lt;/code&gt; classes in Rust:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;gobject_gen!(
    class MyClass: GObject {
        foo: Cell&amp;lt;i32&amp;gt;,
        bar: RefCell&amp;lt;String&amp;gt;,
    }

    impl MyClass {
        virtual fn my_virtual_method(&amp;amp;self, x: i32) {
            // ... do something with x ...
        }
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This looks like a function that is taking a bunch of code as an argument.
This macro would be defined like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#[proc_macro]
pub fn gobject_gen(input: TokenStream) -&amp;gt; TokenStream {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is similar to the derive macro's signature: we get the tokens that
are inside of the parentheses and return the code we want to generate.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#use-and-macros&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;use-and-macros&quot;&gt;&lt;/a&gt;&lt;code&gt;use&lt;/code&gt; and macros&lt;/h3&gt;
&lt;p&gt;You can now &lt;a href=&quot;https://github.com/rust-lang/rust/pull/50911/&quot;&gt;bring macros into scope with the &lt;code&gt;use&lt;/code&gt; keyword&lt;/a&gt;. For example,
to use &lt;code&gt;serde-json&lt;/code&gt;'s &lt;code&gt;json&lt;/code&gt; macro, you used to write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate serde_json;

let john = json!({
    &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;,
    &amp;quot;age&amp;quot;: 43,
    &amp;quot;phones&amp;quot;: [
        &amp;quot;+44 1234567&amp;quot;,
        &amp;quot;+44 2345678&amp;quot;
    ]
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But now, you'd write&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;extern crate serde_json;

use serde_json::json;

let john = json!({
    &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;,
    &amp;quot;age&amp;quot;: 43,
    &amp;quot;phones&amp;quot;: [
        &amp;quot;+44 1234567&amp;quot;,
        &amp;quot;+44 2345678&amp;quot;
    ]
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This brings macros more in line with other items and removes the need for
&lt;code&gt;macro_use&lt;/code&gt; annotations.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/&quot;&gt;&lt;code&gt;proc_macro&lt;/code&gt; crate&lt;/a&gt;
is made stable, which gives you the needed APIs to write these sorts of macros.
It also has significantly improved the APIs for errors, and crates like &lt;code&gt;syn&lt;/code&gt; and
&lt;code&gt;quote&lt;/code&gt; are already using them. For example, before:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust,ignore&quot;&gt;#[derive(Serialize)]
struct Demo {
    ok: String,
    bad: std::thread::Thread,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;used to give this error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0277]: the trait bound `std::thread::Thread: _IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not satisfied
 --&amp;gt; src/main.rs:3:10
  |
3 | #[derive(Serialize)]
  |          ^^^^^^^^^ the trait `_IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not implemented for `std::thread::Thread`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now it will give this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0277]: the trait bound `std::thread::Thread: serde::Serialize` is not satisfied
 --&amp;gt; src/main.rs:7:5
  |
7 |     bad: std::thread::Thread,
  |     ^^^ the trait `serde::Serialize` is not implemented for `std::thread::Thread`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#module-system-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;module-system-improvements&quot;&gt;&lt;/a&gt;Module system improvements&lt;/h2&gt;
&lt;p&gt;The module system has long been a pain point of new Rustaceans; several of
its rules felt awkward in practice. These changes are the first steps we're
taking to make the module system feel more straightforward.&lt;/p&gt;
&lt;p&gt;There's two changes to &lt;code&gt;use&lt;/code&gt; in addition to the aforementioned change for
macros. The first is that &lt;a href=&quot;https://github.com/rust-lang/rust/pull/54404/&quot;&gt;external crates are now in the
prelude&lt;/a&gt;, that is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// old
let json = ::serde_json::from_str(&amp;quot;...&amp;quot;);

// new
let json = serde_json::from_str(&amp;quot;...&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The trick here is that the 'old' style wasn't always needed, due to the way Rust's
module system worked:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust,ignore&quot;&gt;extern crate serde_json;

fn main() {
    // this works just fine; we're in the crate root, so `serde_json` is in
    // scope here
    let json = serde_json::from_str(&amp;quot;...&amp;quot;);
}

mod foo {
    fn bar() {
        // this doesn't work; we're inside the `foo` namespace, and `serde_json`
        // isn't declared there
        let json = serde_json::from_str(&amp;quot;...&amp;quot;);

    }

    // one option is to `use` it inside the module
    use serde_json;

    fn baz() {
        // the other option is to use `::serde_json`, so we're using an absolute path
        // rather than a relative one
        let json = ::serde_json::from_str(&amp;quot;...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moving a function to a submodule and having some of your code break was not a great
experience. Now, it will check the first part of the path and see if it's an &lt;code&gt;extern crate&lt;/code&gt;, and if it is, use it regardless of where you're at in the module hierarchy.&lt;/p&gt;
&lt;p&gt;Finally, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/54404/&quot;&gt;&lt;code&gt;use&lt;/code&gt; also supports bringing items into scope with paths starting with
&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;mod foo {
    pub fn bar() {
        // ...
    }
}

// old
use ::foo::bar;
// or
use foo::bar;

// new
use crate::foo::bar;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;crate&lt;/code&gt; keyword at the start of the path indicates that you would like the path to
start at your crate root. Previously, paths specified after &lt;code&gt;use&lt;/code&gt; would always start at
the crate root, but paths referring to items directly would start at the local path,
meaning the behavior of paths was inconsistent:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;mod foo {
    pub fn bar() {
        // ...
    }
}

mod baz {
    pub fn qux() {
        // old
        ::foo::bar();
        // does not work, which is different than with `use`:
        // foo::bar();

        // new
        crate::foo::bar();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once this style becomes widely used, this will hopefully make absolute paths a bit more
clear and remove some of the ugliness of leading &lt;code&gt;::&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All of these changes combined lead to a more straightforward understanding of how paths
resolve. Wherever you see a path like &lt;code&gt;a::b::c&lt;/code&gt; someplace other than a &lt;code&gt;use&lt;/code&gt; statement,
you can ask:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is &lt;code&gt;a&lt;/code&gt; the name of a crate? Then we're looking for &lt;code&gt;b::c&lt;/code&gt; inside of it.&lt;/li&gt;
&lt;li&gt;Is &lt;code&gt;a&lt;/code&gt; the keyword &lt;code&gt;crate&lt;/code&gt;? Then we're looking for &lt;code&gt;b::c&lt;/code&gt; from the root of our crate.&lt;/li&gt;
&lt;li&gt;Otherwise, we're looking for &lt;code&gt;a::b::c&lt;/code&gt; from the current spot in the module hierarchy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The old behavior of &lt;code&gt;use&lt;/code&gt; paths always starting from the crate root still applies. But
after making a one-time switch to the new style, these rules will apply uniformly to
paths everywhere, and you'll need to tweak your imports much less when moving code around.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#raw-identifiers&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;raw-identifiers&quot;&gt;&lt;/a&gt;Raw Identifiers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/53236/&quot;&gt;You can now use keywords as identifiers&lt;/a&gt; with some new syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// define a local variable named `for`
let r#for = true;

// define a function named `for`
fn r#for() {
    // ...
}

// call that function
r#for();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn't have many use cases today, but will once you are trying to use a Rust 2015
crate with a Rust 2018 project and vice-versa because the set of keywords will be
different in the two editions; we'll explain more in the upcoming blog post about
Rust 2018.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#no_std-applications&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;no_std-applications&quot;&gt;&lt;/a&gt;&lt;code&gt;no_std&lt;/code&gt; applications&lt;/h2&gt;
&lt;p&gt;Back in Rust 1.6, we announced the &lt;a href=&quot;https://blog.rust-lang.org/2016/01/21/Rust-1.6.html&quot;&gt;stabilization of &lt;code&gt;no_std&lt;/code&gt; and
&lt;code&gt;libcore&lt;/code&gt;&lt;/a&gt; for building
projects without the standard library. There was a twist, though: you could
only build libraries, but not applications.&lt;/p&gt;
&lt;p&gt;With Rust 1.30, you can &lt;a href=&quot;https://github.com/rust-lang/rust/pull/51366/&quot;&gt;use the &lt;code&gt;#[panic_handler]&lt;/code&gt;&lt;/a&gt; attribute
to implement panics yourself. This now means that you can build applications,
not just libraries, that don't use the standard library.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#other-things&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-things&quot;&gt;&lt;/a&gt;Other things&lt;/h2&gt;
&lt;p&gt;Finally, you can now &lt;a href=&quot;https://github.com/rust-lang/rust/pull/53370/&quot;&gt;match on visibility keywords, like &lt;code&gt;pub&lt;/code&gt;, in
macros&lt;/a&gt; using the &lt;code&gt;vis&lt;/code&gt; specifier. Additionally, &amp;quot;tool
attributes&amp;quot; like &lt;code&gt;#[rustfmt::skip]&lt;/code&gt; &lt;a href=&quot;https://github.com/rust-lang/rust/pull/53459/&quot;&gt;are now
stable&lt;/a&gt;. Tool &lt;em&gt;lints&lt;/em&gt;
like &lt;code&gt;#[allow(clippy::something)]&lt;/code&gt; are not yet stable, however.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1300-2018-10-25&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;A few new APIs were &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#stabilized-apis&quot;&gt;stabilized for this
release&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ipv4Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ipv6Addr::{LOCALHOST, UNSPECIFIED}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator::find_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, the standard library has long had functions like &lt;code&gt;trim_left&lt;/code&gt; to eliminate
whitespace on one side of some text. However, when considering right-to-left (RTL)
languages, the meaning of &amp;quot;right&amp;quot; and &amp;quot;left&amp;quot; gets confusing. As such, we're introducing
new names for these APIs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;trim_left&lt;/code&gt; -&amp;gt; &lt;code&gt;trim_start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trim_right&lt;/code&gt; -&amp;gt; &lt;code&gt;trim_end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trim_left_matches&lt;/code&gt; -&amp;gt; &lt;code&gt;trim_start_matches&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trim_right_matches&lt;/code&gt; -&amp;gt; &lt;code&gt;trim_end_matches&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We plan to deprecate (but not remove, of course) the old names in Rust 1.33.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1300-2018-10-25&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;The largest feature of Cargo in this release is that we now &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/5995/&quot;&gt;have a progress
bar!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-10-25-Rust-1.30/demo.gif&quot; alt=&quot;demo gif&quot; /&gt;&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1300-2018-10-25&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-130.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-130.0&quot;&gt;&lt;/a&gt;Contributors to 1.30.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.30. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.30.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Update on the October 15, 2018 incident on crates.io</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/10/19/Update-on-crates.io-incident.html" type="text/html" title="Update on the October 15, 2018 incident on crates.io" />
        <published>2018-10-19</published>
        <id>https://blog.rust-lang.org/2018/10/19/Update-on-crates.io-incident.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/10/19/Update-on-crates.io-incident.html">&lt;p&gt;On Monday, Oct 15, starting at approximately 20:00 UTC, crates.io sustained
an operational incident. You can find the status page report &lt;a href=&quot;http://status.crates.io/incidents/cymjwvkrtjn3&quot;&gt;here&lt;/a&gt; and our
tweets about it &lt;a href=&quot;https://twitter.com/cratesiostatus/status/1051953125030940674&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#root-cause&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;root-cause&quot;&gt;&lt;/a&gt;Root Cause&lt;/h2&gt;
&lt;p&gt;A user called &lt;code&gt;cratesio&lt;/code&gt; was created on crates.io and proceeded to upload
packages using common, short names. These packages contained nothing beyond a
&lt;code&gt;Cargo.toml&lt;/code&gt; file and a &lt;code&gt;README.md&lt;/code&gt; instructing users that if they wanted to use
the name, they should open an issue on the crates.io issue tracker.&lt;/p&gt;
&lt;p&gt;The rate at which this user uploaded packages eventually resulted in our servers
being throttled by GitHub, causing a slowdown in all package uploads or yanks.
Endpoints which did not involve updating the index were unaffected.&lt;/p&gt;
&lt;p&gt;We decided to take action on this behavior because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The contents of the uploaded packages appeared to be an attempt to impersonate
the crates.io team (both through the username &lt;code&gt;cratesio&lt;/code&gt;, as well as directing people
to the crates-io issue tracker in the crates' &lt;code&gt;Readme&lt;/code&gt; files)&lt;/li&gt;
&lt;li&gt;the rate of uploading impacted the stability of the service&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#action-taken&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;action-taken&quot;&gt;&lt;/a&gt;Action Taken&lt;/h2&gt;
&lt;p&gt;The user's IP address was banned immediately. We then backdated the users' packages to remove
their packages from the homepage. We also redirected the &lt;code&gt;cratesio&lt;/code&gt; user's page to a 404.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;cratesio&lt;/code&gt; user and all crates they uploaded were deleted.
The user was reported to GitHub, and has since been banned by them.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#timeline-of-events&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;20:09 UTC: The GitHub user &lt;code&gt;cratesio&lt;/code&gt; registers an account&lt;/li&gt;
&lt;li&gt;20:13 UTC: This user begins uploading packages at a rate of roughly one package
every 2 seconds&lt;/li&gt;
&lt;li&gt;20:17 UTC: All requests updating the index begin to take 10+ seconds&lt;/li&gt;
&lt;li&gt;20:41 UTC: An email is sent to the Rust moderation team reporting this user&lt;/li&gt;
&lt;li&gt;20:46 UTC: The report is forwarded to the crates.io team&lt;/li&gt;
&lt;li&gt;20:50 UTC: The user is reported in the crates.io team Discord.&lt;/li&gt;
&lt;li&gt;21:00 UTC: The user's IP address is blocked from accessing the site&lt;/li&gt;
&lt;li&gt;21:20 UTC: The user's packages were removed from the crates.io homepage&lt;/li&gt;
&lt;li&gt;21:20 UTC: The incident is announced on status.crates.io&lt;/li&gt;
&lt;li&gt;22:49 UTC: The user's account page on crates.io is removed.&lt;/li&gt;
&lt;li&gt;23:58 UTC: The packages, all associated data, and the user's account are deleted
from crates.io&lt;/li&gt;
&lt;li&gt;00:40 UTC: The packages are removed from the index.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#future-measures&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;future-measures&quot;&gt;&lt;/a&gt;Future measures&lt;/h2&gt;
&lt;p&gt;It should not have been possible for a single user or IP address to upload that
many packages in a short period of time. We will be introducing rate limiting on
this endpoint to limit the number of packages a script is able to upload in the
future.&lt;/p&gt;
&lt;p&gt;We are also looking into disallowing usernames that could be impersonating
official Rust teams. We will be updating our policies to clearly state that this
form of impersonation is not allowed. We will be deciding the exact wording of
this policy in the coming weeks.&lt;/p&gt;
&lt;p&gt;While it is impossible to tell a user's intent, many, including the team, have
speculated that this action was either associated with or directly related to the
recent escalation in community frustration around crates.io policies, in particular,
the squatting policy.&lt;/p&gt;
&lt;p&gt;Regardless of whether this incident had this intent, the cratesio team would like
to reiterate that taking actions such as the one we experienced on Tuesday is not
an appropriate nor effective way to contribute to dialogue about crates.io policy.
We will be adding a policy making it clear that attempting to disrupt crates.io in order
to make or further a point is not appropriate and will be considered a malicious attack.
We will be deciding on the exact wording of this policy in the coming weeks.&lt;/p&gt;
&lt;p&gt;If you feel that a policy is problematic, the correct place to propose a change is by
creating an RFC or messaging the team at help@crates.io.&lt;/p&gt;
&lt;p&gt;We also have seen a lot of frustration that the crates.io team is not listening to the concerns
that are being raised on both official and unofficial Rust forums. We agree that we should
improve our communication with the community and intend to develop more processes
for folks to communicate with us, as well as for the team to communicate to the general
community.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#background&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;There has been a growing amount of discussion in the community around our
squatting policy and our decision not to have namespacing.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/crates-io-package-policies/1041&quot;&gt;The original squatting policy&lt;/a&gt;,
published in 2014, contains a lot more information about the rationale behind
the policy than what is currently on our website. The full text of the original
policy is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nobody likes a “squatter”, but finding good rules that define squatting that
can be applied mechanically is notoriously difficult. If we require that the
package has at least some content in it, squatters will insert random content.
If we require regular updates, squatters will make sure to update regularly,
and that rule might apply over-zealously to packages that are relatively
stable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;A more case-by-case policy would be very hard to get right, and would almost
certainly result in bad mistakes and and regular controversies.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Instead, we are going to stick to a first-come, first-served system. If someone
wants to take over a package, and the previous owner agrees, the existing
maintainer can add them as an owner, and the new maintainer can remove them. If
necessary, the team may reach out to inactive maintainers and help mediate the
process of ownership transfer. We know that this means, in practice, that
certain desirable names will be taken early on, and that those early users may
not be using them in the most optimal way (whether they are claimed by squatters
or just low-quality packages). Other ecosystems have addressed this problem
through the use of more colorful names, and we think that this is actually a
feature, not a bug, of this system. We talk about this more below.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We will be discussing whether including some of this information in the policy
published on our website would help more people to understand the rationale
behind our policy, without requiring members of the team to reply to every forum
thread wanting to re-litigate what has already been discussed at length.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We wanted to share the details of what happened and why the crates.io team chose to take action
as quickly as possible. The policy changes we've described will be discussed
during the next several team meetings. Nothing is set in stone until the team
has a chance to discuss them further, but we wanted to share the possible
changes we're discussing to limit speculation on what future actions we're
planning on taking.&lt;/p&gt;
&lt;p&gt;As a reminder, if you would like to report an incident regarding cratesio, you
can message the team at help@crates.io. You can view the status of the service
at https://crates-io.statuspage.io/ and/or by following @cratesiostatus on Twitter.&lt;/p&gt;
</content>

        <author>
            <name>The Crates.io Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.29.2</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/10/12/Rust-1.29.2.html" type="text/html" title="Announcing Rust 1.29.2" />
        <published>2018-10-12</published>
        <id>https://blog.rust-lang.org/2018/10/12/Rust-1.29.2.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/10/12/Rust-1.29.2.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.29.2. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.29.2 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1292-2018-10-11&quot;&gt;detailed release notes for
1.29.2&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.29.2-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.29.2-stable&quot;&gt;&lt;/a&gt;What's in 1.29.2 stable&lt;/h2&gt;
&lt;p&gt;This patch release introduces a workaround to a &lt;a href=&quot;https://github.com/rust-lang/rust/issues/54462&quot;&gt;miscompilation bug&lt;/a&gt;
introduced in Rust 1.29.0. We haven't found the root cause of the bug yet, but
it showed up after a LLVM version upgrade, and it's caused by an optimization.
We disabled that optimization until the root cause is fixed.&lt;/p&gt;
&lt;p&gt;This release also includes the &lt;code&gt;rls-preview&lt;/code&gt; rustup component for Windows GNU
users, which wasn't included in the 1.29.0 release due to a build failure. We
also added safeguards in the release infrastructure to prevent stable and beta
releases with missing components for Tier 1 platform in the future.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.29.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html" type="text/html" title="Announcing Rust 1.29.1" />
        <published>2018-09-25</published>
        <id>https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.29.1. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.29.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1291-2018-09-25&quot;&gt;detailed release notes for
1.29.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.29.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.29.1-stable&quot;&gt;&lt;/a&gt;What's in 1.29.1 stable&lt;/h2&gt;
&lt;p&gt;A &lt;a href=&quot;https://blog.rust-lang.org/2018/09/21/Security-advisory-for-std.html&quot;&gt;security vulnerability&lt;/a&gt; was found in the standard library where if a
large number was passed to &lt;code&gt;str::repeat&lt;/code&gt; it could cause a buffer overflow
after an integer overflow. If you do not call the &lt;code&gt;str::repeat&lt;/code&gt; function you
are not affected. This has been addressed by unconditionally panicking in
&lt;code&gt;str::repeat&lt;/code&gt; on integer overflow. More details about this can be found in the
&lt;a href=&quot;https://blog.rust-lang.org/2018/09/21/Security-advisory-for-std.html&quot;&gt;security announcement&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
</feed>